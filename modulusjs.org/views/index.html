<!DOCTYPE html>
<html>
<head>
    <meta name="keywords" content="Javascript Module Definition, Module Library, Service Locator, Module Definition, Javascript Dependency Injection, Dependency Injection, Javascript IoC, Javascript Inversion of Control, Ioc, Inversion of Control, AMD, Asynchronous Module Definition, requirejs alternative, require.js alternative, require.js alternatives, Interface Injection">
    <link href="css/home.css" media="all" rel="stylesheet" type="text/css">
</head>
<body>
    <header>
        <img src="img/header.png">
    </header>
    <!-- Side Navigation -->
    <div class="side-nav">
        <ul>
            <li>
                Download
                <ul>
                    <li>Minified</li>
                </ul>
            </li>
        </ul>
    </div>
    <section class="main-content">
        <!-- Overview -->
        <h1>Overview</h1>
        <p>
            Modulus provides your javascript application with a Service Locator that allows you to easily register and locate other modules.
        </p>

        <p>
            Modulus simplifies your module definitions by autowiring module function parameters based on the paramater name.  <br/>
            e.g. having a parameter called moduleA in your module function will result in modulus finding moduleA and passing it to your module function. <br/>

            By ensuring that module names are unique, we can simplify resolving modules, and eliminate the need of worrying about paths, etc.
        </p>

        <h2>Service Locator</h2>
        <p>
            Modulus is a <a href="http://en.wikipedia.org/wiki/Service_locator_pattern">Service Locator</a>, in that it provides a central place to register your modules,
            and a means to find modules from within other modules. <br/>
            More specifically, Modulus is a <a href="http://martinfowler.com/articles/injection.html">Dynamic Service Locator</a>, as services are registered and found at runtime.
        </p>

        <h2>AMD Loader</h2>
        <p>
            Modulus provides the ability to intelligently* load module dependencies/scripts during runtime.
        </p>

        <h2>Node.js Build Tool/Script Optimizer</h2>
        <p>
            You can compile your modules into one or more script files to optimize the number of http requests made at runtime.
        </p>

        <h1>API</h1>

        <h2>Defining Modules</h2>
        <p>
            There are several options for defining modules with Modulus.
        </p>

            <h3>Modulus Function</h3>
            <p>
                Modulus provides a simplified version of the typical 'define' and 'require' functions found in other AMD libraries.<br/>
                To do the equivalent of define, simply pass in a named function to the 'm' or 'modulus' function.<br/>
                To do the equivalent of require, simply pass in a unnamed function to the 'm' or 'modulus' function.<br/>
            </p>
            <pre class="brush: js">
                //define a module named 'moduleA' by passing in a named function.
                m(function moduleA(){
                    return {
                        prop1: 123
                    };
                });

                //require moduleA by passing in a unnamed function with a parameter named moduleA
                m(function (moduleA){
                    console.log(moduleA.prop1); //prints 123
                });
            </pre>

            <h3>Global Module Functions</h3>
            <p>
                In perhaps the easiest way possible, Modulus allows you to define modules with global functions.<br/>
                Any dependencies on other modules are simply identified via parameter names, where the parameter name matches the name of the desired module.
            </p>
            <pre class="brush: js">
                //defining a module is as simple as creating a function.
                function moduleA(){
                    return {
                        prop1: 123
                    };
                }

                //simply by referencing moduleA, you will get its return value passed in as the parameter value.
                function moduleB(moduleA){
                    return {
                        prop1: moduleA.prop1 + 1 //evaluates to 124
                    };
                }

                //let modulus know to execute moduleB once init has been called.
                moduleB.module = {autoInit:true};

                //the use of global functions means that we must explicitly call init.
                modulus.init({context:window});
            </pre>
            <p>
                When using this option for defining modules, we must explicitly call 'init' so that modulus can scan the context for modules. <br/>
                We must also provide module metadata (via moduleB.module), and instruct Modulus to run the moduleB function once init has been called.
            </p>


        <h2>Configuration</h2>
        <p>
            Modulus offers a powerful configuration that allows you to override any function within the Modulus, allowing you to completely customize behavior. <br/>
            Configuration is achieved by calling the 'init' function, and passing in an object literal with the desired settings.
        </p>
        <h2>Shim for 3rd Party Libraries</h2>
        <p>
            To shim third party libraries which do not use the Modulus convention for defining modules, we can provide a shim configuration.
        </p>
        <pre class="brush: js">
            //shim configuration a few libraries.
            modulus.init({
                shim:{
                    //define the jquery shim. The key '$' represents the parameter name modules will use to require jquery.
                    //the exports represents the global variable the third party library exposes.
                    '$':{
                        dependencies:[],
                        exports:'$'
                    },
                    '_':{
                        dependencies: [],
                        exports:'_'
                    },
                    //Backbone depends on 2 other 3rd party libraries: jquery and underscore.
                    //We must list those as dependencies so that they are loaded before Backbone is.
                    'Backbone':{
                        dependencies: ['_', '$'],
                        exports:'Backbone'
                    }
                }
            });

            m(function ($, Backbone){
                $('#someId');
                console.log(Backbone.VERSION);
            });

        </pre>

    </section>

    <script src="js/modulus.js"></script>
    <script src="js/jquery-1.10.2.min.js"></script>
    <script>
        m.init({
            shim:{
                'SyntaxHighlighter':{
                    dependencies:[],
                    exports:'SyntaxHighlighter'
                },
                'SyntaxHighlighterWithJsBrush':{
                    dependencies:['SyntaxHighlighter'],
                    exports:'SyntaxHighlighter'
                }
            },
            asyncMap:{
                'SyntaxHighlighter':'shCore',
                'SyntaxHighlighterWithJsBrush': 'shBrushJScript'
            },
            asyncFileLoad:function(moduleName, callback, errorback){
                var root = 'js/';
                moduleName = this.asyncMap[moduleName];

                var path = root+moduleName + '.js';
                $.ajax({
                    url: path,
                    crossDomain:true, //allow local file system cross domain requests.
                    dataType: "script",
                    success: callback
                }).fail(function(err){errorback(err)});
            }
        });
    </script>

    <script type="text/javascript">
        m(function(SyntaxHighlighterWithJsBrush){
            SyntaxHighlighterWithJsBrush.all();
        });
    </script>
</body>
</html>